'''Symbolic polynomial rings that do not expand their coefficients

Sympy's support for nested rings of polynomials (polynomials over certain
variables whose coefficients are polynomials over different variables) is
somewhat weak.  In particular, when expanding a symbolic expression involving
nested polynomials, the coefficients of the outer polynomial are fully
expanded.  This expansion destroys any CSE structure in the original expression.
To avoid the expansion, we roll our own symbolic polynomial class.'''

from __future__ import with_statement
from collections import defaultdict
import sympy
import numpy

class SymbolicPolynomialRing(object):
  def __init__(self,gens,standardize):
    '''Create a symbolic polynomial ring generated by the variables in gens.
    Coefficients are assumed comparable via standardize(c0)==standardize(c1).'''
    self.gens = tuple(gens)
    self.standardize = standardize
    self.zeros = (0,)*len(self.gens)

  def singletons(self):
    i = numpy.arange(len(self.gens))
    return [SymbolicPoly(self,{tuple((i==j).astype(int)):1}) for j in i]

class SymbolicPoly(object):
  def __init__(self,ring,terms):
    self.ring = ring
    self.terms = terms

  def __neg__(self):
    terms = dict((k,-v) for k,v in self.terms.iteritems())
    return SymbolicPoly(self.ring,terms)

  def __add__(self,p):
    terms = defaultdict(lambda:0,self.terms)
    if isinstance(p,SymbolicPoly):
      for k,v in p.terms.iteritems():
        terms[k] += v
    else:
      terms[self.ring.zeros] += p
    return SymbolicPoly(self.ring,terms)

  __radd__ = __add__

  def __sub__(self,p):
    terms = defaultdict(lambda:0,self.terms)
    if isinstance(p,SymbolicPoly):
      for k,v in p.terms.iteritems():
        terms[k] -= v
    else:
      terms[self.ring.zeros] -= p
    return SymbolicPoly(self.ring,terms)

  def __rsub__(self,p):
    if isinstance(p,SymbolicPoly):
      return p-self
    return -self+p

  def __mul__(self,p):
    if isinstance(p,SymbolicPoly):
      terms = defaultdict(lambda:0)
      for k0,v0 in self.terms.iteritems():
        for k1,v1 in p.terms.iteritems():
          terms[tuple(numpy.array(k0)+k1)] += v0*v1
    else:
      terms = dict(terms)
      for k,v in terms.iteritems():
        terms[k] *= p
    return SymbolicPoly(self.ring,terms)

  __rmul__ = __mul__

  def homogeneous(self):
    degrees = set()
    standardize = self.ring.standardize
    for k,v in self.terms.iteritems():
      v = standardize(v)
      if v:
        for d in v.monoms():
          degrees.add(sum(d)+sum(k))
    assert len(degrees)<=1, 'nonhomogeneous expansion: %s, degrees %s'%(self,list(degrees))
    if degrees: 
      return tuple(degrees)[0]

  def filter(self):
    nonzero = self.ring.standardize
    return SymbolicPoly(self.ring,dict((k,v) for k,v in self.terms.iteritems() if nonzero(v)))

  def __str__(self):
    gens = self.ring.gens
    terms = sorted(self.terms.items())
    return ' + '.join('(%s)%s'%(v,''.join(('*%s%s'%(g,'^%d'%p if p>1 else '') if p else '') for g,p in zip(gens,d))) for d,v in terms)
